jdk download
in ur machine --> u will be having jvm --> irrespective of os 
hardware top of that os top of that jvm(without jvm we can't run java file)
java is platform independent --> you can run your application on any machine
irrespective of hardware or Os
ur application is independent , but jvm is dependent --> jvm is need to be built for particular OS
code --> compiler --> byte code --> goes on --> run on jvm 
the first file need to have main method . the execution starts from the first file
main has provide particular signature --> public static void main*(String a[])
javac Hello.java -> compile
java Hello --> run
u need extra libraries , and the environment(jre)
jvm is the part of the jre
jdk --> jre--> jvm
if u want to run ur application in ur friends machine --> jre and jvm are installed
---> variable 
      Temporary storage
      data must be numeric,text,Image

Data type -- Primitive -- Integer - byte,short,int,long
                       -- Float -- double,float
                       -- character 
                       --Boolean --> True/False

int --> 4 bytes --> (-231) to (231-1)
long --> 8 bytes --> -263 to 263-1
short --> 2 bytes  --> -215 to 215 -1
byte --> 1 byte  --> -128 to 127

double num = 5.6;
float num = 5.6f;

char -> 2 bytes
char c = 'k';

boolean --> true or false
(0,1) does not work

boolean b = true

--->Type conversion and casting

byte b = 127;
int a = 256;
wrong --> b = a;
correct --> a = b;

Type casting
b = (byte)a; --> ur converting integer to byte format
float f = 5.6f;
int x = (int)f;

Type promotion
byte a = 10;
byte b = 30;
int result = a*b;

What kind of error will be thrown if the main method is not found in the Java program? Run time error
Which of the following is the valid way to represent a long literal in Java?
123L,123l,0b1010L
What is the default value assigned to a variable of boolean type? false
What does a high-order bit represent for an integer? sign of the integer

logical operators 

& - AND 
| - OR
!- Not

In terms of reading files,data base and networks --> while loop make sense
In terms of frequency for loop make sense
Which conditional statement is used to check multiple possible values of a variable? switch
int x = 5
int y=10
int z = (x++ > 5 && y-- < 10) ? x-- : y

1. Initial values
x = 5
y = 10

2.condition evaluation:

(x++ > 5 && y-- < 10)

x++ maeans use the current value of x then increment 
x++ > 5 becomes 5>5 which is false
after this x gets incremented so x become 6

y--< 10
because the first part of the && condition x++ > 5 is false ,the second part y--<10 will not be evaluated (short-circuit behaviour)
y remains unchanged at 10
since the entire condition false ,the false part of the ternary executed 
so x=6 and y = 10 

class and object theory
java is an object oriented programming
using pen,mouse --> object
everything around you is an object
even treat humans as an object
every object know some thing and every object does something
u have to give the design
u have to create a class file it will act as a blue print for some one who can create object for you in java
who creates objects in java --> jvm but u give the blue print

methods and variables

JDK -- java development kit --> compile the code 
on JVM run the code --> java virtual machine
jre --> java run time environment 
jre have all the extra files , extra classes 
and it also validates the byte code 
jdk --> jre --> jvm

---> methods 
class Computer 
{
public void playMusic() 
{
System.out.println("Music Playing")
}
public String getMeAPen(int cost) 
{
if(cost >= 10) 
return "Pen";
else
 return "Nothing"
}
}

public class Demo 
{
public satic void main(String a[]) 
{
Computer obj = new Computer();
obj.playMusic();
String str = obj.getMeAPen(10);
System.out.println(str);
}
}

class Calculator 
{
    int a;
    public int add(int num1,int num2)
    {
    // System.out.println("in add");
    //int r = num1+num2;
    return num1+num2;
    }
    public int add(int num1,int num2,int num3)
    {
    // System.out.println("in add");
    //int r = num1+num2;
    return num1+num2+num3;
    }
    public double add(double num1,int num2)
    {
    // System.out.println("in add");
    //int r = num1+num2;
    return num1+num2;
    }
   
}


public class Twonumbersusingclass {
   public static void main(String a[])
   {
     // int num1=4;
     // int num2=5;
      Calculator calc = new Calculator(); //object creation
     int result = calc.add(3,4);
     int r = calc.add(3,4,5);
    //   int result = num1+num2;
      System.out.println(result);
   } 
}

same method name and different type of parameters -- method overloading

-->jvm  has two categories of memory
1) stack  -> last in first out
2) heap --> it expands
stack you stored data in different sequence 
In heap open space
a in above code become instance variable 
num1,num2 are local  variables
local variables are part of stack 
and instance variables are part of heap

need of an array

array -- in a variable we can store a value 
int i=5;
int j = 6;
int k = 7;
we have to store all three values in one variable
int num[] = {5,6,7}
int num1[] = new int[4]

multi dimensional array
An array of arrays , nums array will be having three different arrays
int nums[][] = new int[3][4] 

Does the main() method overloaded in java -- yes

What will happen if a local variable has the same name as an instance variable within a class?

local variable hides the instance variable

Question 5:
What will be printed after the execution of the given code?

class Message{

public void printMessage(int message) {

System.out.println("Message primitive: " + message);

}



public void printMessage(Integer message) {

System.out.println("Message object: " + message);

}

}



class Main{

public static void main(String []ars){

Message ob=new Message();

ob.printMessage(5);

}

}

message primitive: 5
Where are instance variables allocated in memory? - head

Which subsystem of the JVM is responsible for loading class files?
class loader

what type of data is allowed in an array in java
- homogeous data type only

What does arr[arr.length-1].length represents in a multidimensional array?
length of the last row in the array

drawbacks of array - for operations it takes more time 
we can't store multiple data types 

but it is useful for fixed size 
for storing multiple things we can use collections

Array of objects
by default integer array will be zero 
if we use nums.length --> we can't get any error 
belong to class --> instance variables
belong to method --> local variables 

enhanced for loop
for(int n: nums) 
{
System.out.println(n);
}

string - double quotes
char - single quotes

string is a class

public class Demo 
{
public static void main(String a[])
{
String name = "navin" //It works but string is a class we have to create 
object for it
String name = new String("navin");
System.out.println(name);
System.out.println(name.hashCode());
System.out.println("hello" + name);
System.out.println(name.charAt(1));
System.out.println(name.concat("reddy"));
}
}

Different Types of strings
Mutable vs Immutable string
Mutable - something will change
Immutable - something will not change

public class Demo 
{
public static void main(String a[])
{
String name = "navin" 
name = name + "reddy";
System.out.println("hello"+name)
String s1 = "Navin"
String s2 = "Navin"
System.out.println(s1 == s2)
}
}
it doesn't create the new object . It always refer to the existing one 
even for concatation it doesn't change , it create the new string
so the above code belongs to Immuatable.
by default strings are immuatable once you create the object u can't change it
string buffer and string builder --> both provide u way to implement 
mutable string.

---> String Builder and String Buffer
public class Demo
{
public static void main(String a[])
{
StringBuffer sb = new StringBuffer("Navin");
System.out.println(sb.capacity) --> 16 characters
System.out.println(sb.length()); --> 5 
sb.append("Reddy")
sb.deleteCharAt(2)
System.out.println(sb);  --> nain reddy
String str = sb.toString();
sb.insert(0,"java")
sb.setLength(30);
sb.ensureCapacity(minimumCpacity:100)

stringBuffer -- thread safe 
string builder -- not thread safe 

If there is no continuous location inside your heap memory . there's no continuous next .
if there is no location available. There's no space available.
In that case it has to relocate.

static variable -- every object will have a different value 
but what if i want common value for all the objects.


class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
}
public class Demo 
{
public static void main(String a[]) 
{
Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
obj1.name = "Smart Phone";

Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
obj1.name = "Smart Phone";

obj1.name = "Phone"

obj1.show()
obj2.show()

}
}
O/P:
Apple:1500:Phone

static variable should be  called only with class Names  you can call with objects but avoid it

class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
}
public class Demo 
{
public static void main(String a[]) 
{
Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
Mobile.name = "Smart Phone";

Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
Mobile.name = "Smart Phone";

obj1.name = "Phone"

obj1.show()
obj2.show()

}
}

static is belong to the class

=> static methods

class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
public static void show1() 
{
System.out.println("in static method");
}
}

public class Demo 
{
public static void main(String a[]) 
{
Mobile.show1()
}
}

class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
public static void show1() 
{
System.out.println(brand + " : " + price  + " : " + name);
}
}

public class Demo 
{
public static void main(String a[]) 
{
Mobile.show1()
}
}

non static variable can't have access in static method
because we have two different object brand and price --> it confuse which one to take

class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
public static void show1(Mobile obj) 
{
System.out.println(obj.brand + " : " + obj.price  + " : " + obj.name);
}
}

public class Demo 
{
public static void main(String a[]) 
{
Mobile.show1(obj1)
}
}

main --> static --> no need object
if we initialized static varaiable in constructor every time  creation of object 
it will be initialized so we don't want to do that 
to achieve that we have special block  called static block
static 
{
name ="Phone"
}
irrespective of how many objects create it will call only one time 
class loads & objects are instantiated
every time we load the class it will call --> static block
if we don't create the object class will not load
Class.forName("Mobile") --> public static void main(String a[])  throws ClassNotFoundException
you just load the class

Encapsulation

encapsulation is part of oops
class Human
{
private int age;'
private String name;

public int getAge() 
{
   return age;
}
public void setAge(int a) 
{
   age = a;
}
public void setName(String n) 
{
   name = n;
}
public String getName(String s) 
{
    return name;
}
}

public class Demo 
{
public static void main(String a[]) 
{
Human obj = new Human();
obj.setAge(11);
obj.setName("mouni");

System.out.println(obj.getName() + " ")
}
}
if i use private only same class can be used
outside world can't use that variable for using that we use getters and setters
we are binding the data with methods no one from outside world use ur variables directly 
someone we are encaspulating data and methods

class Human
{
private int age;'
private String name;

public int getAge() 
{
   return age;
}
public void setAge(int age) 
{
   this.age = age;
}
public void setName(String name) 
{
   this.name = name;
}
public String getName() 
{
    return name;
}
}

public class Demo 
{
public static void main(String a[]) 
{
Human obj = new Human();
obj.setAge(11);
obj.setName("mouni");

System.out.println(obj.getName() + " ")
}
}

this keyword

public void setAge(int age) {
Human obj1 = new Human()  -- but its creating new object
obj1.age = age
}
obj1.age --> instance variable
age --> local variable

class Human
{
private int age;'
private String name;

public int getAge() 
{
   return age;
}
public void setAge(int age,Human obj) 
{
   this.age = age;
}
public void setName(String name) 
{
   this.name = name;
}
public String getName() 
{
    return name;
}
}

public class Demo 
{
public static void main(String a[]) 
{
Human obj = new Human();
obj.setAge(11,obj);
obj.setName("mouni");

System.out.println(obj.getName() + " ")
}
}

public void setAge(int age,Human obj) {
Human obj1 = obj -- but its creating new object
obj1.age = age
}

obj.setAge(30,obj); --we mentioning obj two times

don't create the object and don't pass the object

This is a keyword which represents --> the current object
object is calling the method

Constructors 
when object is created i will assign the value 
constructor is a method it has the same name as a class name.so those are the rules 
u have to rememeber. a constructor never returns anything.you don't have to mention int,float
or string anything there.specify the acess it is public and the mention name ,which is human

class Human
{
private int age;'
private String name;

public Human() 
{
System.out.println("in constructor")
}

public int getAge() 
{
   return age;
}
public void setAge(int age,Human obj) 
{
   this.age = age;
}
public void setName(String name) 
{
   this.name = name;
}
public String getName() 
{
    return name;
}
}

public class Demo 
{
public static void main(String a[]) 
{
Human obj = new Human();
obj.setAge(11,obj);
obj.setName("mouni");

System.out.println(obj.getName() + " ")
}
}

we can assign the values by using (setters and getters) or constructors
In constructor we can connect our project with database

method overloading

public Human()
{
age = 12;
name = "john";
}

public Human(int a,String n) //Parameterized Constructor
{
age = a;
name = n;
}

public Human(String name) {
this.age = 12;
this.name = name;
}

public Human(int age,String name) 
{
this.age = age;
this.name = name;
}

if u don't make a constructor , the empty constructor automatically created

//Camel casing

class and interface- Calc,Runnable
variable and method - starts with a small letter - marks and show()
constants - all capital - PIE,BRAND
//showMyMarks() - CAMELCASING 
MyData
age,DATA,Human()

Anonymous object

class A 
{
public A()
{
System.out.println("object created");
}
public void show() 
{
System.out.println("in A show");
}
}
public class Demo
{
public static void main(String a[]) 
{
int marks;
marks = 99;
A obj;
obj = new A();
obj.show();
}
}
class A 
{
public A()
{
System.out.println("object created");
}
public void show() 
{
System.out.println("in A show");
}
}
public class Demo
{
public static void main(String a[]) 
{

 new A(); // anonymous object --. don't have a name 
//you have the new object in the heap
new A().show();
}
}

what is inheritance
class Calc 
{
public int add(int n1,int n2) 
{
   return n1+n2;
}
public int sub(int n1,int n2) 
{
   return n1-n2;
}
}



public class AdvCalc 
{
public int multi(int n1,int n2) 
{
return n1*n2;
}
public int div(int n1,int n2) 
{
return n1/n2;
}
}

public class Demo 
{
public static void main(String a[]) 
{
Calc obj = new Calc(); if we use AdvCalc obj = new AdvCalc(); we can't use add and sub
int r1 = obj.add(4,5)
int r2 = obj.sub(7,5);

}
}

public class AdvCalc extends calc
{
public int multi(int n1,int n2) 
{
return n1*n2;
}
public int div(int n1,int n2) 
{
return n1/n2;
}
}
then we can use both the class methods
advCalc --> sub class
Calc --> super class


--> need of inheritance 
oops basically stands for object oriented programming
in object oriented programming --> we have object,class,encapsulation

Inheritance(is/has)
desktop has a motherboard 
desktop has a hard drive,it has a CPU(Important keyboard is has)

class Calculator 
{
add()
sub()
multi()
}
class AdvCalc 
{
we already have this features of basic calculator so we extend that
}

so basically inheritance is a very important feature using which you can just copy the feature from the upper class
parent,super,base 
child,sub,derived

Single and multiple inheritance

public class veryAdvCalc extends AdvCalc
{
public double power(int n1,int n2) {
return Math.pow(n1,n2);
}
}

calc 
advCalc extends Calc
veryadvCalc extends advcalc

only one level --> single level inheritance 
multiple levels -->multi level inheritance

multiple inheritance
A and B both are parents of C

class A {

}
class B {

}
class C  extends A,B{

}

multiple inheritance in java will not work
if A and B both has this method , whch one he will choose  --> Ambiguity problem
In java multiple inheritance does not work
java does not support multiple inheritance

This and super method 

class A 
{
public A(){
System.out.println("in A")
}

}
class B extends A 
{
public B() 
{
System.out.println("in B")
}
public B(int n) 
{
System.out.println("in B int")
}

}
public class Demo
{
public static void main(String a[])
{
B obj = new B();

}
}
O/P:
in A
in B

It will call the constructor of both

public class Demo
{
public static void main(String a[])
{
B obj = new B(5);

}
}
O/P:
In A
In B int
every constructor of java has a 1st stament is super method
whenerver we create the object of class it will call the constructor of subclass and superclass
both.
every constructor in java has a method is super
this method is there even we don't mention
every class in java extends object class
object is class in java which has so many methods
even if we don't mention

class A extends object
{

}
class B extends A
{

}
so this is multi level inheritance
this() will execute the constructor of same class
class A 
{
public A(){
System.out.println("in A")
}

}
class B extends A 
{
public B() 
{
System.out.println("in B")
}
public B(int n) 
{
this();
System.out.println("in B int")
}

}
public class Demo
{
public static void main(String a[])
{
B obj = new B();

}
}
O/P:
in A
in B
in B int

method overriding

class A 
{
public void show() 
{
System.out.println("in A show");
}
public void config()
{
System.out.println("In A Config")
}
}

class B extends A 
{
public void show1() 
{
System.out.println("in B show")
}
public class Demo 
{
public static void main(String a[]) 
{
B obj = new B();
obj.show()
obj.config();
}}

method overloading have same name but different parameters 

In method overriding -
It will be same name and same parameters as well but it will have different behaviour

class Calc 
{
public int add(int n1,int n2) 
{
return n1+n2;
}
}

class AdvCalc extends Calc 
{
public int add(int n1,int n2) 
{
return n1+n2+1;
}
}
public class Demo 
{
public static void main(String a[]) 
{
AdvCalc obj = new AdvCalc();
int r1 = obj.add(3,4);
System.out.println(r1);
}}

child class method is overriding the method of parent class

packages

we use keword package - package

To put your classes in a package

import tools.Calc;
import tools.AdvCalc;
import java.util.Arraylist;

public class Demo 
{
public static void main(String a[])
{
ArrayList list = new ArrayList();
AdvCalc obj = new AdvCalc();
Calc obj = new Calc();
}
}
by default java.lang imported in every java file

import java.lang.*
import tools.*

package other.tools;
import other.tools;

package --> should be unique

Access modifiers

protected
public
if u want to access outside the package -> then it  must be public
public means it can be accessed where from anywhere
private --> use in same class
private variables can be used in same class irrespective of the package 
             private        protected      public      default

same class     yes             yes           yes         yes

same package   No              yes           yes         yes

same package   No              yes           yes          yes
non-subclass   
 
different package No           yes           yes          No
subclass

different package  No          No            yes          No
non-subclass

class public

Keep your variables , instance variables --> private

methods --> public

Polymorphism

Poly - many 
morphism  - behaviour

so the same object or the same reference

compile time polymorphism - early binding - behaviour defined at compile time
runtime polymorphism - late binding


add(int,int)
add(int,int,int)

class A and Class B to add two different classes
so ur behaviour of your reference 
or execution will change based on some situation

dynamic method dispatch(run time polymorphism)
class A 
{
public void show()
{
System.out.println("in A show");
}
}
class B extends A 
{
public void show()
{
System.out.println("in B show");
}
}
class C extends A 
{
public void show()
{
System.out.println("in C show");
}
}

public class Demo
{
public static void main(String a[]) 
{
A obj = new A();
obj.show();
}
}
o/p:
In A show

public class Demo
{
public static void main(String a[]) 
{
A obj = new A();
obj.show();

obj = new B();
obj.show();
}

obj = new  C();
obj.show();
}
o/p:
In A show
In B show
In C show

Irespective of what type of object you have , what type of variable you create 
Its type A , it will depend on what type of object u have
it is only possible you have inheritance
we don't know what is the output till we run the code 


Final keyword - variable ,method,class

public class Demo
{
public static void main(String a[]) 
{
  final int num = 8;
    num = 9;
 when you make a variable as a final variable
 the variable become constant
  once you assign the value you can't change it


final method  --

final class Calc 
{
public void show() 
{
System.out.println("in Calc show");
}
public void add(int a, int b) {
System.out.println(a+b);
}

class AdvCalc extends Calc 
{

}
public class demo
{
public static void main(String a[])
{
Calc obj = new Calc();
obj.show();
obj.add(4,5);
}

The type advanced calculator cannot be a subclass of the final class
when you make the final you are basically stopping the inheritance

when you make a class final it means no one can extend it

to stop method overriding
you make ur method as final no one can override it

Oject class equals to StringHashcode

every class in java extend the object class


object class equals to hash code

class Laptop
{
String model;
int price;

public String toString() 
{
retun "Hey"
}}

public class Demo 
{
public static void main(String a[]) 
{
Laptop obj = new Laptop()
obj.model = "lenovo yoga"
obj.price = 1000;
System.out.println(obj);
}
}
O/P: hey

class Laptop
{
String model;
int price;

public String toString() 
{
retun  model + ":" + price
}}

public class Demo 
{
public static void main(String a[]) 
{
Laptop obj = new Laptop()
obj.model = "lenovo yoga"
obj.price = 1000;
System.out.println(obj);
}
}
O/P: Lenovo Yoga

public class Demo 
{
public static void main(String a[]) 
{
Laptop obj1 = new Laptop()
obj.model = "lenovo yoga"
obj.price = 1000;

Laptop obj2 = new Laptop()
obj.model = "lenovo yoga"
obj.price = 1000;
boolean result = obj1 == obj2; //obj1.equals(obj2) they are comparing based on hexa decimal values
System.out.println(result);
}
}
O/P: false

public boolean equals(Laptop that) 
{
   if(this.model.equals(that.model) && this.price == that.price) 
  {
   return true;
   }
  else
{
  return false;
}
}
}

public boolean equals(Laptop that) 
{
  return  this.model.equals(that.model) && this.price == that.price  
}

every time we print the obj it will call automatically toString method

if you don't have a method in your class it will method in super class
so we created method itself


Upcasting and downcasting

public class Demo
{
public static void main(String a[]) 
{
double d = 4.5;
int i = (int)d;  you are converting into type of a value
}
}
in the world of oops

class A 
{
  public void show1() 
{
s.p.o("in A show");
}
}
class B  extends A
{
public void show2() 
{
s.p.o("in B show")
}

}

public class Demo 
{
public static void main(String a[])
{
//  A obj = new A():
A obj = new B() --> I can have a reference of A and object of B 
A obj = (A) new B(); // which is upcasting
obj.show1();
}
}

now what is downcasting?

public class Demo 
{
public static void main(String a[])
{
A obj = new B();
obj.show1();

B obj1 = (B) obj;
obj1.show2();

}
}

Wrapper classes
int,float they are primitive types not object types

collection framework 

In array we have primitive types
 Wrapper class
int --> Integer
char --> Character
double --> Double


for every primitive type we have class for it

public class Demo 
{
public static void main(String a[]) 
{
int num = 7;(primitive variable )
//Integer num1 = new Intger(8);(reference variable) //boxing
Integer num1 = 8;
int num2 = num1.intValue();  -->  unboxing // getting value from object type
System.out.println(num2) 

boxing -- you are taking a value that storing that in a primitive object
or in a wrapper object 

when u store a primitive type in the object automatically
unboxing  --> take out the value from the object


String str = "12"
int num3 = Integer.parseInt(str);

System.out.println(num3*2);

Abstract keyword

abstract class Car 
{
public abstract void drive();
public abstarct void fly();

public void playMusic()
{
System.out.println("playMusic");
}
}
class WagonR extends Car 
{
public void fly()
{
System.out.println("flying...")
}
public void drive()
{
System.out.println("Driving...")
}
}

public class Demo 
{
public static void main(String a[]) 
{
 Car obj = new WagonR();
obj.drive();
obj.playMusic();
}
}

you can have the abstract method only in the abstract class
if u are extending abstract class u need to define it
otherwise it will not work
you can't create object of the abstract class
but it create a reference of abstract class
abstract class with which only has abstarct methods
you can have abstract class which has only implemented methods
you can have abstact class which has both abstract and non abstract methods
if  you have a class which is not able to implement all the methods in this case even this class become abstarct

===> Inner class

class A 
{
int age;
public void show()
{
System.out.println("in show");
}
class B 
{
 public void config() 
 {
  System.out.println("in config")
 }
}
}

public class Demo 
{
public static void main(String a[]) 
{
A obj = new A();
obj.show();

A.B obj1 = obj.new B();
obj1.config();
}
}

if it is a static class B --> no need of obj --> A.B obj1 = new A.B();
static can be used for only the inner class

Anonymous Inner class -- Anonymous doesn't have a name
class A {
public void show() 
{
System.out.println("in A show");
}
}

class B extends A 
{
public void show() 
{
System.out.println("in b SHOW");
}
}


public class Demo 
{
public static void main(String a[]) 
{
A obj = new A();
obj.show();
}

iF THE INNER CLASS USED ONLY ONCE
SO WHY TO CREATE A NEW CLASS
HOW WILL YOU GET A NEW IMPLEMENTATION

public class Demo 
{
public static void main(String a[]) 
{
A obj = new A();
{
      public void show() 
      {
      System.out.println("in new show");
      }
};
obj.show();
}

-->ABSTARCT AND ANONYMOUS INNER CLASS
abstract class A 
{
public abstract void show();
public abstract void config();
}
public class Demo 
{
public static void main(String a[]) 
{
A obj = new A();
{
      public void show() 
      {
      System.out.println("in new show");
      }
       public void config() 
      {
      System.out.println("in config");
      }
};
obj.show();
}
HERE WE ARE NOT CREATING THE OBJECT OF ABSTRACT CLASS WE ARE CREATING THE OBJECT OF  ANONYMOUS CLASS

what is an interface?
if you have a class it only have a abstract methods then we can create a interface
abstarct class A 
{
public abstract void show();
public abstarct void config();

}

public class Demo
{
public static void main(String a[])
{

}
}


interface A 
{
int age = 44;  // by default final and static // that means we have to first initialize the variable
String area = "Mumbai";
public abstract void show();  // void show(); --> even we don't mention  public abstract it default public abstarct
public abstarct void config();

}

Class B implements A 
{
public void show() 
      {
      System.out.println("in new show");
      }
       public void config() 
      {
      System.out.println("in config");
      }
}
public class demo 
{
public static void main(String a[]) 
{
A obj;
obj = new A();//YOU CAN'T INSTANTIATE 
obj = new B();
obj.show();
obj.config();
S.o.P(A.area);
}
}

INTERFACE TELLS WHAT ARE THE METHODS YOU NEED
BUT I WILL NOT IMPLEMENT THEM 
iTS YOUR JOB TO IMPLEMENT
INTERFACE SHOWS YOU THE DESIGN 
if you fail to define both the methods by default your class also become abstract
in implements we can only implement the method not variables so it used interface name
so it is static
we can't create the memory . so if you don't have your own memory , how can you have non final variable?


More on interfaces

abstarct class A 
{
public abstract void show();
public abstarct void config();

}

public class Demo
{
public static void main(String a[])
{

}
}


interface A 
{
int age = 44;  // by default final and static // that means we have to first initialize the variable
String area = "Mumbai";
public abstract void show();  // void show(); --> even we don't mention  public abstract it default public abstarct
public abstarct void config();

}
interface X
{

void run();
}

interface Y extends X
{

}

Class B implements A , X
{
public void show() 
      {
      System.out.println("in new show");
      }
       public void config() 
      {
      System.out.println("in config");
      }
public void run() 
      {
      System.out.println("run");
      }

}
public class demo 
{
public static void main(String a[]) 
{
A obj;
obj = new A();//YOU CAN'T INSTANTIATE 
obj = new B();
obj.show();
obj.config();
S.o.P(A.area);
X obj1 = new B();
obj1.run();
}
}

Because in abstract class ,we can extend only one class
In interface you can have a class implementing multiple interfaces

class - class --> extends 
class -- interface --> implements
interface - interface --> extends

need of interface 

abstarct class Computer
{
public  abstract void code();
}

class Laptop extends Computer
{
public void code()
{
System.out.println("coding...,compile,run")
}
}
class Desktop extends Computer
{
public void code()
{
System.out.println("coding...,compile,run:Faster")

}
}
class developer 
{
  public void devApp(Computer lap) 
  {
  lap.code();

  }
}
public class Demo 
{
public static void main(String a[]) 
{
Computer lap = new Laptop();
Computer desk = new Desktop();
Developer navin = new Developer();
navin.devApp(desk);
}
}

interface Computer
{
 void code();
}

class Laptop impleemnts Computer
{
public void code()
{
System.out.println("coding...,compile,run")
}
}
class Desktop implements Computer
{
public void code()
{
System.out.println("coding...,compile,run:Faster")

}
}
class developer 
{
  public void devApp(Computer lap) 
  {
  lap.code();

  }
}
public class Demo 
{
public static void main(String a[]) 
{
Computer lap = new Laptop();
Computer desk = new Desktop();
Developer navin = new Developer();
navin.devApp(desk);
}
}

enum Status{
Running,Failed,Pending,Success;
}

public class Demo 
{
public static void main(String a[])
{
int i = 5;
Status s  = Status.Success;
Status[] ss = Status.values();
System.out.println(s.ordinal());
System.out.println(ss[0]) --> running
for(Status s: ss) 
{
System.out.println(s  + " : " + s.ordinal());
}
}
}
that status is a class there 
Running,Failed,Pending,Success --> objects 
named constants 
if you have a scenerio where you want to use constants we can use this concept
Status s = Status.Pending;
if(s == Status.Ruuning) 
      System.out.println("All Good")
else if( s == Status.Failed) 
   System.out.println("Try Again")
else if(s == Status.Pending)
    System.out.println("Please wait")
 else
    System.out.println("Done")

Status s = Status.Running;
switch(s)
{
   case Running:
       System.out.println("All Good");
       break;
   case Failed:
        System.out.println("Try Again")
        break;
   case Pending:
        System.out.println("Try Again")
        break;
   default
        System.out.println("Done")
        break; 
}

Enum class
we can extend any other class
you can't extend enum with any other class
you can create constructors 
you can also create own varibales inside the enum
Enum in java extends the enum class all these extra methods getting from enum class
class java.lang.Enum

enum Laptop {
Macbook(2000),XPS(2200) , Surface

private int price;
private Laptop() 
{
  price = 500;
}
private Laptop(int price)
{
this.price = price;
}
pubic int getPrice()
{
return price; 
}
public void setPrice(int price) {
this.price = price;
}
}
public class Demo
{
public static void main(String a[]) 
{
//Laptop lap = Laptop.Macbook;
//System.out.println(lap + " : " + lap.getPrice());
for(Laptop lap: Laptop.values())  {
System.out.println(lap +  " : " + lap.getPrice());
}
}

we are using it as a private constructor , not a default or the public 
Its because we are creating the object in the same class itself
thats how private constructor works you can create the object in the same class

what is annotation
now anootation simply means a supplement  to the compiler or to the run time
we want to supply extra information to the compiler or to the run time

class A 
{
public void showTheDataWhichBelongsToThisClass() 
{

System.out.println("in A show")
}
}
class B extends A 
{
@Override
public void showTheDataWhichBelongToThisClass()  //then it will come error
{

System.out.println("in A show")
}
}

public class Demo
{
publid static void main(String[] args)
{
B obj = new B() 
obj.showTheDataWhichBelongsToThisClass();
}
}
there is a difference in class names. so if u want to call B method but it call A method

in spring framework and hybernate framework mostly driven in annotations

@Depecated --> some one using or not using

Types of interface

1)Normal - two or more methods
2)functional -- called as SAM(Single abstaract method)
3)Marker -- which has no methods

Lambda expression

@FunctionalInterface
interface A 
{
void show(int i,int j);
}
public class Demo 
{
public static void main(String a[]) 
{
A obj = (i,j) -> System.out.println("in new show"+i);

obj.show(5,8);
}

Lambda expression with return

@FunctionalInterface
interface A 
{
int add(int i,int j);
}
public class Demo 
{
public static void main(String a[]) 
{
A obj = (i,j) -> i+j;
int result = obj.add(5,4);
System.out.println(result);
}

83) what is exception

error --> compile time error/Run time error/logical

System.out.Println( --> syntax error compile time error

Logical time error  --> steps are wrong

runtime issues  --> code will stop at the middle --> exception handling

exception handling using try catch

statements --> normal 
      ----> critical

public class Demo 
{
public static void main(String a[]) 
{
int i =0;
try
{
int j = 18/i;
}
catch
{
System.out.println("Something went wrong)

}
System.out.println(j);  --> Airthmetic exception

Try with multiple catch

  























   












































































 











































                         








