jdk download
in ur machine --> u will be having jvm --> irrespective of os 
hardware top of that os top of that jvm(without jvm we can't run java file)
java is platform independent --> you can run your application on any machine
irrespective of hardware or Os
ur application is independent , but jvm is dependent --> jvm is need to be built for particular OS
code --> compiler --> byte code --> goes on --> run on jvm 
the first file need to have main method . the execution starts from the first file
main has provide particular signature --> public static void main*(String a[])
javac Hello.java -> compile
java Hello --> run
u need extra libraries , and the environment(jre)
jvm is the part of the jre
jdk --> jre--> jvm
if u want to run ur application in ur friends machine --> jre and jvm are installed
---> variable 
      Temporary storage
      data must be numeric,text,Image

Data type -- Primitive -- Integer - byte,short,int,long
                       -- Float -- double,float
                       -- character 
                       --Boolean --> True/False

int --> 4 bytes --> (-231) to (231-1)
long --> 8 bytes --> -263 to 263-1
short --> 2 bytes  --> -215 to 215 -1
byte --> 1 byte  --> -128 to 127

double num = 5.6;
float num = 5.6f;

char -> 2 bytes
char c = 'k';

boolean --> true or false
(0,1) does not work

boolean b = true

--->Type conversion and casting

byte b = 127;
int a = 256;
wrong --> b = a;
correct --> a = b;

Type casting
b = (byte)a; --> ur converting integer to byte format
float f = 5.6f;
int x = (int)f;

Type promotion
byte a = 10;
byte b = 30;
int result = a*b;

What kind of error will be thrown if the main method is not found in the Java program? Run time error
Which of the following is the valid way to represent a long literal in Java?
123L,123l,0b1010L
What is the default value assigned to a variable of boolean type? false
What does a high-order bit represent for an integer? sign of the integer

logical operators 

& - AND 
| - OR
!- Not

In terms of reading files,data base and networks --> while loop make sense
In terms of frequency for loop make sense
Which conditional statement is used to check multiple possible values of a variable? switch
int x = 5
int y=10
int z = (x++ > 5 && y-- < 10) ? x-- : y

1. Initial values
x = 5
y = 10

2.condition evaluation:

(x++ > 5 && y-- < 10)

x++ maeans use the current value of x then increment 
x++ > 5 becomes 5>5 which is false
after this x gets incremented so x become 6

y--< 10
because the first part of the && condition x++ > 5 is false ,the second part y--<10 will not be evaluated (short-circuit behaviour)
y remains unchanged at 10
since the entire condition false ,the false part of the ternary executed 
so x=6 and y = 10 

class and object theory
java is an object oriented programming
using pen,mouse --> object
everything around you is an object
even treat humans as an object
every object know some thing and every object does something
u have to give the design
u have to create a class file it will act as a blue print for some one who can create object for you in java
who creates objects in java --> jvm but u give the blue print

methods and variables

JDK -- java development kit --> compile the code 
on JVM run the code --> java virtual machine
jre --> java run time environment 
jre have all the extra files , extra classes 
and it also validates the byte code 
jdk --> jre --> jvm

---> methods 
class Computer 
{
public void playMusic() 
{
System.out.println("Music Playing")
}
public String getMeAPen(int cost) 
{
if(cost >= 10) 
return "Pen";
else
 return "Nothing"
}
}

public class Demo 
{
public satic void main(String a[]) 
{
Computer obj = new Computer();
obj.playMusic();
String str = obj.getMeAPen(10);
System.out.println(str);
}
}

class Calculator 
{
    int a;
    public int add(int num1,int num2)
    {
    // System.out.println("in add");
    //int r = num1+num2;
    return num1+num2;
    }
    public int add(int num1,int num2,int num3)
    {
    // System.out.println("in add");
    //int r = num1+num2;
    return num1+num2+num3;
    }
    public double add(double num1,int num2)
    {
    // System.out.println("in add");
    //int r = num1+num2;
    return num1+num2;
    }
   
}


public class Twonumbersusingclass {
   public static void main(String a[])
   {
     // int num1=4;
     // int num2=5;
      Calculator calc = new Calculator(); //object creation
     int result = calc.add(3,4);
     int r = calc.add(3,4,5);
    //   int result = num1+num2;
      System.out.println(result);
   } 
}

same method name and different type of parameters -- method overloading

-->jvm  has two categories of memory
1) stack  -> last in first out
2) heap --> it expands
stack you stored data in different sequence 
In heap open space
a in above code become instance variable 
num1,num2 are local  variables
local variables are part of stack 
and instance variables are part of heap

need of an array

array -- in a variable we can store a value 
int i=5;
int j = 6;
int k = 7;
we have to store all three values in one variable
int num[] = {5,6,7}
int num1[] = new int[4]

multi dimensional array
An array of arrays , nums array will be having three different arrays
int nums[][] = new int[3][4] 

Does the main() method overloaded in java -- yes

What will happen if a local variable has the same name as an instance variable within a class?

local variable hides the instance variable

Question 5:
What will be printed after the execution of the given code?

class Message{

public void printMessage(int message) {

System.out.println("Message primitive: " + message);

}



public void printMessage(Integer message) {

System.out.println("Message object: " + message);

}

}



class Main{

public static void main(String []ars){

Message ob=new Message();

ob.printMessage(5);

}

}

message primitive: 5
Where are instance variables allocated in memory? - head

Which subsystem of the JVM is responsible for loading class files?
class loader

what type of data is allowed in an array in java
- homogeous data type only

What does arr[arr.length-1].length represents in a multidimensional array?
length of the last row in the array

drawbacks of array - for operations it takes more time 
we can't store multiple data types 

but it is useful for fixed size 
for storing multiple things we can use collections

Array of objects
by default integer array will be zero 
if we use nums.length --> we can't get any error 
belong to class --> instance variables
belong to method --> local variables 

enhanced for loop
for(int n: nums) 
{
System.out.println(n);
}

string - double quotes
char - single quotes

string is a class

public class Demo 
{
public static void main(String a[])
{
String name = "navin" //It works but string is a class we have to create 
object for it
String name = new String("navin");
System.out.println(name);
System.out.println(name.hashCode());
System.out.println("hello" + name);
System.out.println(name.charAt(1));
System.out.println(name.concat("reddy"));
}
}

Different Types of strings
Mutable vs Immutable string
Mutable - something will change
Immutable - something will not change

public class Demo 
{
public static void main(String a[])
{
String name = "navin" 
name = name + "reddy";
System.out.println("hello"+name)
String s1 = "Navin"
String s2 = "Navin"
System.out.println(s1 == s2)
}
}
it doesn't create the new object . It always refer to the existing one 
even for concatation it doesn't change , it create the new string
so the above code belongs to Immuatable.
by default strings are immuatable once you create the object u can't change it
string buffer and string builder --> both provide u way to implement 
mutable string.

---> String Builder and String Buffer
public class Demo
{
public static void main(String a[])
{
StringBuffer sb = new StringBuffer("Navin");
System.out.println(sb.capacity) --> 16 characters
System.out.println(sb.length()); --> 5 
sb.append("Reddy")
sb.deleteCharAt(2)
System.out.println(sb);  --> nain reddy
String str = sb.toString();
sb.insert(0,"java")
sb.setLength(30);
sb.ensureCapacity(minimumCpacity:100)

stringBuffer -- thread safe 
string builder -- not thread safe 

If there is no continuous location inside your heap memory . there's no continuous next .
if there is no location available. There's no space available.
In that case it has to relocate.

static variable -- every object will have a different value 
but what if i want common value for all the objects.


class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
}
public class Demo 
{
public static void main(String a[]) 
{
Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
obj1.name = "Smart Phone";

Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
obj1.name = "Smart Phone";

obj1.name = "Phone"

obj1.show()
obj2.show()

}
}
O/P:
Apple:1500:Phone

static variable should be  called only with class Names  you can call with objects but avoid it

class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
}
public class Demo 
{
public static void main(String a[]) 
{
Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
Mobile.name = "Smart Phone";

Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
Mobile.name = "Smart Phone";

obj1.name = "Phone"

obj1.show()
obj2.show()

}
}

static is belong to the class

=> static methods

class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
public static void show1() 
{
System.out.println("in static method");
}
}

public class Demo 
{
public static void main(String a[]) 
{
Mobile.show1()
}
}

class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
public static void show1() 
{
System.out.println(brand + " : " + price  + " : " + name);
}
}

public class Demo 
{
public static void main(String a[]) 
{
Mobile.show1()
}
}

non static variable can't have access in static method
because we have two different object brand and price --> it confuse which one to take

class Mobile 
{
   String brand;
   int price;
   static String name;

    public void show() 
    {
System.out.println(brand + " : " + price  + " : " + name);
    }
public static void show1(Mobile obj) 
{
System.out.println(obj.brand + " : " + obj.price  + " : " + obj.name);
}
}

public class Demo 
{
public static void main(String a[]) 
{
Mobile.show1(obj1)
}
}

main --> static --> no need object
if we initialized static varaiable in constructor every time  creation of object 
it will be initialized so we don't want to do that 
to achieve that we have special block  called static block
static 
{
name ="Phone"
}
irrespective of how many objects create it will call only one time 
class loads & objects are instantiated
every time we load the class it will call --> static block
if we don't create the object class will not load
Class.forName("Mobile") --> public static void main(String a[])  throws ClassNotFoundException
you just load the class

Encapsulation

encapsulation is part of oops
class Human
{
private int age;'
private String name;

public int getAge() 
{
   return age;
}
public void setAge(int a) 
{
   age = a;
}
public void setName(String n) 
{
   name = n;
}
public String getName(String s) 
{
    return name;
}
}

public class Demo 
{
public static void main(String a[]) 
{
Human obj = new Human();
obj.setAge(11);
obj.setName("mouni");

System.out.println(obj.getName() + " ")
}
}
if i use private only same class can be used
outside world can't use that variable for using that we use getters and setters
we are binding the data with methods no one from outside world use ur variables directly 
someone we are encaspulating data and methods

class Human
{
private int age;'
private String name;

public int getAge() 
{
   return age;
}
public void setAge(int age) 
{
   this.age = age;
}
public void setName(String name) 
{
   this.name = name;
}
public String getName() 
{
    return name;
}
}

public class Demo 
{
public static void main(String a[]) 
{
Human obj = new Human();
obj.setAge(11);
obj.setName("mouni");

System.out.println(obj.getName() + " ")
}
}

this keyword

public void setAge(int age) {
Human obj1 = new Human()  -- but its creating new object
obj1.age = age
}
obj1.age --> instance variable
age --> local variable

class Human
{
private int age;'
private String name;

public int getAge() 
{
   return age;
}
public void setAge(int age,Human obj) 
{
   this.age = age;
}
public void setName(String name) 
{
   this.name = name;
}
public String getName() 
{
    return name;
}
}

public class Demo 
{
public static void main(String a[]) 
{
Human obj = new Human();
obj.setAge(11,obj);
obj.setName("mouni");

System.out.println(obj.getName() + " ")
}
}

public void setAge(int age,Human obj) {
Human obj1 = obj -- but its creating new object
obj1.age = age
}

obj.setAge(30,obj); --we mentioning obj two times

don't create the object and don't pass the object

This is a keyword which represents --> the current object
object is calling the method

Constructors 
when object is created i will assign the value 
constructor is a method it has the same name as a class name.so those are the rules 
u have to rememeber. a constructor never returns anything.you don't have to mention int,float
or string anything there.specify the acess it is public and the mention name ,which is human

class Human
{
private int age;'
private String name;

public Human() 
{
System.out.println("in constructor")
}

public int getAge() 
{
   return age;
}
public void setAge(int age,Human obj) 
{
   this.age = age;
}
public void setName(String name) 
{
   this.name = name;
}
public String getName() 
{
    return name;
}
}

public class Demo 
{
public static void main(String a[]) 
{
Human obj = new Human();
obj.setAge(11,obj);
obj.setName("mouni");

System.out.println(obj.getName() + " ")
}
}

we can assign the values by using (setters and getters) or constructors
In constructor we can connect our project with database

method overloading

public Human()
{
age = 12;
name = "john";
}

public Human(int a,String n) //Parameterized Constructor
{
age = a;
name = n;
}

public Human(String name) {
this.age = 12;
this.name = name;
}

public Human(int age,String name) 
{
this.age = age;
this.name = name;
}

if u don't make a constructor , the empty constructor automatically created

//Camel casing

class and interface- Calc,Runnable
variable and method - starts with a small letter - marks and show()
constants - all capital - PIE,BRAND
//showMyMarks() - CAMELCASING 
MyData
age,DATA,Human()

Anonymous object

class A 
{
public void show() 
{







































 











































                         








